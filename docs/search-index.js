var searchIndex = JSON.parse('{\
"automates":{"doc":"","t":"FAAADNNDENLLLLLLLLLLLLMLLLLLLLLLLMLLLLMFMLLLLLLLLLLLLLRRRFFNNNNELLLLLLLLLFLLL","n":["main","rule_parser","rules","tokenizer","Grammar","None","Rule","RuleJSONEntry","RuleToken","Token","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","content","default","deserialize","eq","eq","fmt","fmt","fmt","from","from","from","init_state","into","into","into","new","non_terminal","parse_grammar","rules","serialize","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","ERR","INF","SUC","apply_grammar","apply_rule","Int","Keyword","Linebreak","String","TokenType","borrow","borrow_mut","clone","clone_into","eq","fmt","from","into","to_owned","tokenizer","try_from","try_into","type_id"],"q":[[0,"automates"],[4,"automates::rule_parser"],[54,"automates::rules"],[59,"automates::tokenizer"],[77,"core::result"],[78,"serde::de"],[79,"core::fmt"],[80,"core::fmt"],[81,"serde::ser"],[82,"core::any"],[83,"core::option"]],"d":["","","","","This is the grammar structure It contains the initial …","","This is a non-terminal character, typically represented by …","","These are the components of a rule","This is a string, typically represented between &lt; and &gt; …","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","This is where the grammar starts at, by default its the …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","The rules of the grammar, the key is the non-terminal …","","","","","","","","","","","","","","","","","It runs apply_rule on all the rules of the initial state, …","This function tries to match a rule against a vector of …","An integer, identified by &lt;num&gt; in the grammar","A keyword, identified by its name in the grammar","A linebreak, identified by \\\\n in the grammar","A variable string, identified by &lt;id&gt; or &lt;str&gt; in the …","Represents a token type Keyword takes a string as argument …","","","","","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","","Transforms a string into a vector of tokens","","",""],"i":[0,0,0,0,0,2,2,0,0,2,2,3,4,2,3,4,2,3,4,2,3,4,4,3,4,2,3,2,3,4,2,3,4,3,2,3,4,3,4,0,3,4,2,3,4,2,3,4,2,3,4,2,3,4,0,0,0,0,0,13,13,13,13,0,13,13,13,13,13,13,13,13,13,0,13,13,13],"f":[[[],1],0,0,0,0,0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[2,2],[3,3],[4,4],[[-1,-2],1,[],[]],[[-1,-2],1,[],[]],[[-1,-2],1,[],[]],0,[[],3],[-1,[[5,[4]]],6],[[2,2],7],[[3,3],7],[[2,8],9],[[3,8],9],[[4,8],9],[-1,-1,[]],[-1,-1,[]],[-1,-1,[]],0,[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[],3],0,[[[10,[4]]],3],0,[[4,-1],5,11],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,12,[]],[-1,12,[]],[-1,12,[]],0,0,0,[[[14,[13]],3],7],[[[14,[13]],[10,[2]],3,15],[[16,[15]]]],0,0,0,0,0,[-1,-2,[],[]],[-1,-2,[],[]],[13,13],[[-1,-2],1,[],[]],[[13,13],7],[[13,8],9],[-1,-1,[]],[-1,-2,[],[]],[-1,-2,[],[]],[17,[[10,[13]]]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,12,[]]],"c":[],"p":[[15,"tuple"],[4,"RuleToken",4],[3,"Grammar",4],[3,"RuleJSONEntry",4],[4,"Result",77],[8,"Deserializer",78],[15,"bool"],[3,"Formatter",79],[6,"Result",79],[3,"Vec",80],[8,"Serializer",81],[3,"TypeId",82],[4,"TokenType",59],[15,"slice"],[15,"usize"],[4,"Option",83],[15,"str"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
